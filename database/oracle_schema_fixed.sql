-- =============================================
-- MBTI 테스트 사이트 Oracle DB 스키마 (수정버전)
-- =============================================

-- 시퀀스 생성 먼저
CREATE SEQUENCE SEQ_USERS START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE SEQ_TEST_RESULTS START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE SEQ_COMMENTS START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE SEQ_DAILY_STATS START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE SEQ_SHARE_LOGS START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE SEQ_LIKES START WITH 1 INCREMENT BY 1;

-- 1. 사용자 테이블 (선택적 회원가입)
CREATE TABLE USERS (
    USER_ID NUMBER PRIMARY KEY,
    USER_UUID VARCHAR2(36) UNIQUE NOT NULL,  -- 브라우저별 고유 식별자
    NICKNAME VARCHAR2(50),                    -- 선택사항
    EMAIL VARCHAR2(100),                      -- 선택사항
    SOCIAL_TYPE VARCHAR2(20),                 -- KAKAO, GOOGLE, NAVER 등
    SOCIAL_ID VARCHAR2(100),                  -- 소셜 로그인 ID
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 2. 테스트 결과 테이블
CREATE TABLE TEST_RESULTS (
    RESULT_ID NUMBER PRIMARY KEY,
    USER_UUID VARCHAR2(36) NOT NULL,         -- 사용자 식별자 (비회원도 가능)
    TEST_TYPE VARCHAR2(20) DEFAULT 'MBTI' NOT NULL, -- 향후 다른 테스트 추가 대비
    MBTI_TYPE VARCHAR2(4) NOT NULL,           -- ENFP, INTJ 등
    DETAILED_SCORES CLOB,                     -- JSON 형태로 세부 점수 저장
    AI_ANALYSIS CLOB,                         -- AI 분석 결과
    TEST_ANSWERS CLOB,                        -- 테스트 답변 (JSON)
    SHARED_COUNT NUMBER DEFAULT 0,            -- SNS 공유 횟수
    VIEW_COUNT NUMBER DEFAULT 0,              -- 결과 조회 횟수
    IS_PUBLIC NUMBER(1) DEFAULT 1,            -- 공개/비공개 (0: 비공개, 1: 공개)
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 3. 댓글 테이블
CREATE TABLE COMMENTS (
    COMMENT_ID NUMBER PRIMARY KEY,
    RESULT_ID NUMBER NOT NULL,                -- 어떤 결과에 대한 댓글인지
    USER_UUID VARCHAR2(36) NOT NULL,          -- 댓글 작성자
    NICKNAME VARCHAR2(50),                    -- 작성자 닉네임
    MBTI_TYPE VARCHAR2(4),                    -- 작성자의 MBTI (선택)
    CONTENT CLOB NOT NULL,                    -- 댓글 내용
    LIKES_COUNT NUMBER DEFAULT 0,             -- 좋아요 수
    IS_DELETED NUMBER(1) DEFAULT 0,           -- 삭제 여부
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 4. 통계 테이블 (일별 집계)
CREATE TABLE DAILY_STATS (
    STAT_ID NUMBER PRIMARY KEY,
    STAT_DATE DATE NOT NULL,                  -- 통계 날짜
    MBTI_TYPE VARCHAR2(4) NOT NULL,           -- MBTI 유형
    TEST_COUNT NUMBER DEFAULT 0,              -- 해당 날짜의 테스트 수
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 5. SNS 공유 로그 테이블
CREATE TABLE SHARE_LOGS (
    SHARE_ID NUMBER PRIMARY KEY,
    RESULT_ID NUMBER NOT NULL,                -- 공유된 결과
    PLATFORM VARCHAR2(20) NOT NULL,           -- KAKAO, INSTAGRAM, FACEBOOK 등
    USER_UUID VARCHAR2(36) NOT NULL,          -- 공유한 사용자
    SHARED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 6. 좋아요/추천 테이블
CREATE TABLE LIKES (
    LIKE_ID NUMBER PRIMARY KEY,
    TARGET_TYPE VARCHAR2(20) NOT NULL,        -- RESULT, COMMENT
    TARGET_ID NUMBER NOT NULL,                -- 대상 ID
    USER_UUID VARCHAR2(36) NOT NULL,          -- 좋아요를 누른 사용자
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- =============================================
-- 제약 조건 추가 (외래키)
-- =============================================

-- 댓글 테이블의 외래키
ALTER TABLE COMMENTS 
ADD CONSTRAINT FK_COMMENTS_RESULT 
FOREIGN KEY (RESULT_ID) REFERENCES TEST_RESULTS(RESULT_ID);

-- SNS 공유 로그의 외래키
ALTER TABLE SHARE_LOGS 
ADD CONSTRAINT FK_SHARE_RESULT 
FOREIGN KEY (RESULT_ID) REFERENCES TEST_RESULTS(RESULT_ID);

-- =============================================
-- 유니크 제약 조건 추가
-- =============================================

-- 통계 테이블의 유니크 제약
ALTER TABLE DAILY_STATS 
ADD CONSTRAINT UK_DAILY_STATS 
UNIQUE (STAT_DATE, MBTI_TYPE);

-- 좋아요 테이블의 유니크 제약
ALTER TABLE LIKES 
ADD CONSTRAINT UK_LIKES 
UNIQUE (TARGET_TYPE, TARGET_ID, USER_UUID);

-- =============================================
-- 인덱스 생성 (성능 최적화)
-- =============================================

-- 자주 조회되는 컬럼에 인덱스 생성
CREATE INDEX IDX_TEST_RESULTS_UUID ON TEST_RESULTS(USER_UUID);
CREATE INDEX IDX_TEST_RESULTS_MBTI ON TEST_RESULTS(MBTI_TYPE);
CREATE INDEX IDX_TEST_RESULTS_DATE ON TEST_RESULTS(CREATED_AT);
CREATE INDEX IDX_COMMENTS_RESULT ON COMMENTS(RESULT_ID);
CREATE INDEX IDX_DAILY_STATS_DATE ON DAILY_STATS(STAT_DATE);

-- =============================================
-- 트리거 생성 (자동화)
-- =============================================

-- 1. 사용자 ID 자동 생성 트리거
CREATE OR REPLACE TRIGGER TRG_USERS_ID
BEFORE INSERT ON USERS
FOR EACH ROW
BEGIN
    IF :NEW.USER_ID IS NULL THEN
        :NEW.USER_ID := SEQ_USERS.NEXTVAL;
    END IF;
END;
/

-- 2. 테스트 결과 ID 자동 생성 트리거
CREATE OR REPLACE TRIGGER TRG_TEST_RESULTS_ID
BEFORE INSERT ON TEST_RESULTS
FOR EACH ROW
BEGIN
    IF :NEW.RESULT_ID IS NULL THEN
        :NEW.RESULT_ID := SEQ_TEST_RESULTS.NEXTVAL;
    END IF;
END;
/

-- 3. 댓글 ID 자동 생성 트리거
CREATE OR REPLACE TRIGGER TRG_COMMENTS_ID
BEFORE INSERT ON COMMENTS
FOR EACH ROW
BEGIN
    IF :NEW.COMMENT_ID IS NULL THEN
        :NEW.COMMENT_ID := SEQ_COMMENTS.NEXTVAL;
    END IF;
END;
/

-- 4. 통계 ID 자동 생성 트리거
CREATE OR REPLACE TRIGGER TRG_DAILY_STATS_ID
BEFORE INSERT ON DAILY_STATS
FOR EACH ROW
BEGIN
    IF :NEW.STAT_ID IS NULL THEN
        :NEW.STAT_ID := SEQ_DAILY_STATS.NEXTVAL;
    END IF;
END;
/

-- 5. 공유 로그 ID 자동 생성 트리거
CREATE OR REPLACE TRIGGER TRG_SHARE_LOGS_ID
BEFORE INSERT ON SHARE_LOGS
FOR EACH ROW
BEGIN
    IF :NEW.SHARE_ID IS NULL THEN
        :NEW.SHARE_ID := SEQ_SHARE_LOGS.NEXTVAL;
    END IF;
END;
/

-- 6. 좋아요 ID 자동 생성 트리거
CREATE OR REPLACE TRIGGER TRG_LIKES_ID
BEFORE INSERT ON LIKES
FOR EACH ROW
BEGIN
    IF :NEW.LIKE_ID IS NULL THEN
        :NEW.LIKE_ID := SEQ_LIKES.NEXTVAL;
    END IF;
END;
/

-- 7. 테스트 결과 생성 시 통계 자동 업데이트 트리거
CREATE OR REPLACE TRIGGER TRG_UPDATE_STATS
AFTER INSERT ON TEST_RESULTS
FOR EACH ROW
DECLARE
    v_stat_date DATE;
    v_count NUMBER;
BEGIN
    v_stat_date := TRUNC(:NEW.CREATED_AT);
    
    -- 이미 존재하는지 확인
    SELECT COUNT(*) INTO v_count
    FROM DAILY_STATS 
    WHERE STAT_DATE = v_stat_date AND MBTI_TYPE = :NEW.MBTI_TYPE;
    
    IF v_count > 0 THEN
        -- 업데이트
        UPDATE DAILY_STATS 
        SET TEST_COUNT = TEST_COUNT + 1
        WHERE STAT_DATE = v_stat_date AND MBTI_TYPE = :NEW.MBTI_TYPE;
    ELSE
        -- 삽입
        INSERT INTO DAILY_STATS (STAT_DATE, MBTI_TYPE, TEST_COUNT)
        VALUES (v_stat_date, :NEW.MBTI_TYPE, 1);
    END IF;
END;
/

-- =============================================
-- 초기 데이터 (샘플)
-- =============================================

-- MBTI 유형별 샘플 통계 데이터 (테스트용)
INSERT INTO DAILY_STATS (STAT_DATE, MBTI_TYPE, TEST_COUNT) VALUES (SYSDATE - 7, 'ENFP', 23);
INSERT INTO DAILY_STATS (STAT_DATE, MBTI_TYPE, TEST_COUNT) VALUES (SYSDATE - 7, 'INFP', 18);
INSERT INTO DAILY_STATS (STAT_DATE, MBTI_TYPE, TEST_COUNT) VALUES (SYSDATE - 7, 'ENFJ', 15);
INSERT INTO DAILY_STATS (STAT_DATE, MBTI_TYPE, TEST_COUNT) VALUES (SYSDATE - 7, 'INFJ', 12);
INSERT INTO DAILY_STATS (STAT_DATE, MBTI_TYPE, TEST_COUNT) VALUES (SYSDATE - 7, 'ENTP', 19);
INSERT INTO DAILY_STATS (STAT_DATE, MBTI_TYPE, TEST_COUNT) VALUES (SYSDATE - 7, 'INTP', 14);
INSERT INTO DAILY_STATS (STAT_DATE, MBTI_TYPE, TEST_COUNT) VALUES (SYSDATE - 7, 'ENTJ', 11);
INSERT INTO DAILY_STATS (STAT_DATE, MBTI_TYPE, TEST_COUNT) VALUES (SYSDATE - 7, 'INTJ', 13);
INSERT INTO DAILY_STATS (STAT_DATE, MBTI_TYPE, TEST_COUNT) VALUES (SYSDATE - 7, 'ESFP', 21);
INSERT INTO DAILY_STATS (STAT_DATE, MBTI_TYPE, TEST_COUNT) VALUES (SYSDATE - 7, 'ISFP', 16);
INSERT INTO DAILY_STATS (STAT_DATE, MBTI_TYPE, TEST_COUNT) VALUES (SYSDATE - 7, 'ESFJ', 25);
INSERT INTO DAILY_STATS (STAT_DATE, MBTI_TYPE, TEST_COUNT) VALUES (SYSDATE - 7, 'ISFJ', 20);
INSERT INTO DAILY_STATS (STAT_DATE, MBTI_TYPE, TEST_COUNT) VALUES (SYSDATE - 7, 'ESTP', 17);
INSERT INTO DAILY_STATS (STAT_DATE, MBTI_TYPE, TEST_COUNT) VALUES (SYSDATE - 7, 'ISTP', 10);
INSERT INTO DAILY_STATS (STAT_DATE, MBTI_TYPE, TEST_COUNT) VALUES (SYSDATE - 7, 'ESTJ', 22);
INSERT INTO DAILY_STATS (STAT_DATE, MBTI_TYPE, TEST_COUNT) VALUES (SYSDATE - 7, 'ISTJ', 24);

COMMIT;

-- =============================================
-- 유용한 쿼리 (참고용)
-- =============================================

-- 전체 통계 조회
SELECT 
    MBTI_TYPE,
    SUM(TEST_COUNT) as TOTAL_TESTS,
    ROUND(SUM(TEST_COUNT) * 100.0 / (SELECT SUM(TEST_COUNT) FROM DAILY_STATS), 2) as PERCENTAGE
FROM DAILY_STATS 
GROUP BY MBTI_TYPE 
ORDER BY TOTAL_TESTS DESC;

-- 최근 7일 인기 MBTI
SELECT 
    MBTI_TYPE,
    SUM(TEST_COUNT) as RECENT_TESTS
FROM DAILY_STATS 
WHERE STAT_DATE >= SYSDATE - 7
GROUP BY MBTI_TYPE 
ORDER BY RECENT_TESTS DESC;

-- 댓글이 많은 결과
SELECT 
    tr.RESULT_ID,
    tr.MBTI_TYPE,
    COUNT(c.COMMENT_ID) as COMMENT_COUNT
FROM TEST_RESULTS tr
LEFT JOIN COMMENTS c ON tr.RESULT_ID = c.RESULT_ID AND c.IS_DELETED = 0
GROUP BY tr.RESULT_ID, tr.MBTI_TYPE
ORDER BY COMMENT_COUNT DESC;
